<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>tlcs simple format</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="ch01-01.html"><strong aria-hidden="true">1.</strong> Timelock Cryptographic Service</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-02.html"><strong aria-hidden="true">1.1.</strong> How It Works?</a></li><li class="chapter-item expanded "><a href="ch01-03.html"><strong aria-hidden="true">1.2.</strong> Security</a></li><li class="chapter-item expanded "><a href="ch01-04.html"><strong aria-hidden="true">1.3.</strong> Alpha Service Demo</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-01.html"><strong aria-hidden="true">2.</strong> Formal Description</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch02-02.html"><strong aria-hidden="true">2.1.</strong> TLCS from NIZK</a></li><li class="chapter-item expanded "><a href="ch02-03.html"><strong aria-hidden="true">2.2.</strong> Efficient TLCS</a></li><li class="chapter-item expanded "><a href="ch02-04.html"><strong aria-hidden="true">2.3.</strong> Correctness</a></li><li class="chapter-item expanded "><a href="ch02-05.html"><strong aria-hidden="true">2.4.</strong> Security Model</a></li><li class="chapter-item expanded "><a href="ch02-06.html"><strong aria-hidden="true">2.5.</strong> TLCS curves</a></li></ol></li><li class="chapter-item expanded "><a href="ch03-01.html"><strong aria-hidden="true">3.</strong> Implementation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-02.html"><strong aria-hidden="true">3.1.</strong> TLCS - C++</a></li><li class="chapter-item expanded "><a href="ch03-03.html"><strong aria-hidden="true">3.2.</strong> TLCS - Rust</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-01.html"><strong aria-hidden="true">4.</strong> Application and Use Cases</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-02.html"><strong aria-hidden="true">4.1.</strong> Noun Project</a></li><li class="chapter-item expanded "><a href="ch04-03.html"><strong aria-hidden="true">4.2.</strong> Timelock Encryption</a></li><li class="chapter-item expanded "><a href="ch04-04.html"><strong aria-hidden="true">4.3.</strong> Commitment</a></li><li class="chapter-item expanded "><a href="ch04-05.html"><strong aria-hidden="true">4.4.</strong> Expiring ZK Proofs</a></li><li class="chapter-item expanded "><a href="ch04-06.html"><strong aria-hidden="true">4.5.</strong> E-voting</a></li><li class="chapter-item expanded "><a href="ch04-07.html"><strong aria-hidden="true">4.6.</strong> TLCS fs</a></li><li class="chapter-item expanded "><a href="ch04-08.html"><strong aria-hidden="true">4.7.</strong> Trustless betting and auctions</a></li><li class="chapter-item expanded "><a href="ch04-09.html"><strong aria-hidden="true">4.8.</strong> Escrow services</a></li><li class="chapter-item expanded "><a href="ch04-10.html"><strong aria-hidden="true">4.9.</strong> Legal and compliance purposes</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">tlcs simple format</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p><img src="../src/img/timelock-logo.png" alt="timelock_timeline.png" /></p>
<h1 id="timelock-cryptographic-service"><a class="header" href="#timelock-cryptographic-service">TimeLock Cryptographic Service</a></h1>
<p><a href="https://www.timelock.zone/">Timelock.zone</a> aims to serve as a public platform that allows companies and individuals to encrypt data for future decryption with support for various cryptographic systems, including the most popular <a href="https://">Elliptic curves</a>.</p>
<p>Timelock is being developed by the <a href="https://research.aragon.org/about/">Aragon ZK Research team</a> using Gears, a COSMOS SDK written in <a href="https://www.rust-lang.org/">Rust</a>.</p>
<h2 id="development-timeline"><a class="header" href="#development-timeline">Development Timeline</a></h2>
<p><img src="../src/img/timelock_timeline.png" alt="timelock_timeline.png" /></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="how-it-works"><a class="header" href="#how-it-works">How It Works?</a></h2>
<p>Choose your preferred cryptographic scheme and a future day (up to 10 years in advance) or hour (up to 2 years in advance) and obtain a public key. You can now encrypt your data and safely share it with others, knowing it can only be decrypted at the specified time in the future, when the corresponding private key will be published on timelock.zone.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="security"><a class="header" href="#security">Security</a></h2>
<p>Our system reiles on the the well-known League of Entropy randomness beacon, drand.love. In addition, a single honest party participating in the computation of the public key is enough to ensure that the private key cannot be uncovered ahead of time. In order to increase security even further, we will allow public participation during the private key preparation phase.</p>
<p>For formal security proof of the protocol read this <a href="https://">section</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="alpha-service-demo"><a class="header" href="#alpha-service-demo">Alpha Service Demo</a></h2>
<p><a href="https://www.timelock.zone/nouns-demo.html">Here</a> we provide a TLCS Alpha Demo.</p>
<h3 id="general-information"><a class="header" href="#general-information">General Information</a></h3>
<p>This is the alpha implementation of the timelock service. There are currently many keys already available and during this alpha period you can request keys be made at no cost.</p>
<blockquote>
<p><strong>NOTE:</strong> These keys should not be used for real world encryption and are for testing purposes only </p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-build-a-time-lock-crypto-service-based-on-league-of-entropy-drand"><a class="header" href="#how-to-build-a-time-lock-crypto-service-based-on-league-of-entropy-drand">How to Build a Time Lock Crypto Service based on League of Entropy (drand)</a></h1>
<h2 id="setting-and-motivation"><a class="header" href="#setting-and-motivation">Setting and motivation</a></h2>
<p>We assume the reader to be familiar with the League of Entropy (a.k.a. <a href="https://drand.love">drand</a>) system but the presentation of our treatment is self-contained.
In the following we denote by \( g_1,g_2 \)</p>
<p>the generators of the groups \(G_1,G_2\) of some prime order \(p\) used by LOE, and by \(PK_L\) the public key of LOE that has the form \(PK_L=g_2^{sk_L}\) where \(sk_L\in Z_p\) is the corresponding secret key that is shared by the LOE members.
For simplicity, in the following we will often say that at time \(C\) LOE releases a secret key \(SK_C\) whereas we should actually refer to a round number rather than a time. 
We recall that LOE is a coalition of members who, at each time interval \(C \), release a BLS signature \(\sigma_C=Hash(C)^{SK_L}\), where \(Hash\) is a (standardized hash function) that maps bit strings to points in \(G_1\) (we skip technical details about the actual encodings of \(C \) . This signature is jointly computed in a threshold fashion by the LOE members in a way that a minority of the members cannot obtain the secret key \(SK_L\) (that is shared by the members). 
To ease our presentation, henceforth we denote by \(SK_C\) the signature \(\sigma_C\) for time \(C\) and we say that \(SK_C\) is the secret key of LOE for time \(C\) . 
For the purpose of our treatment, the reader does not need to know the details of the LOE protocol but simply that at each time interval \(C\) the afore-mentioned secret key \(SK_C\) is publicly available.</p>
<p>We want a cryptographic protocol among a set of parties to jointly construct a public key \(PK\) whose corresponding secret key \(sk\) can be publicly computed only at time greater or equal than \(C\) when the secret key \(SK_C\) of LOE for time \(C\) will be made available; here \(C\) is a public input to all parties.
The public key \(PK\) should have the form \(g^{sk}\) where \(g\) is the generator of a group of some prime order \(q\), so \(sk \in Z_q\). We look for generic approaches so we consider any kind of prime order group in which the Dlog Assumption holds: that is elliptic curve groups (both bilinear and non-bilinear groups) and multiplicative groups of prime order; <a href="ch02-01.html#Generalization-to-any-homomorphic-OWF-and-thus-to-RSA">later on</a> we will also cover a specific RSA setting.
This public key \(PK\) can be then used for encryption using any encryption scheme defined over the group generated by \(g\) (later on we will also discuss other applications to digital signatures and zero-knowledge proofs).</p>
<p>Observe that this problem, though related, is independent from the recently proposed <a href="https://eprint.iacr.org/2015/482">timelock encryption</a> primitive. Indeed, a user Alice can use the public key \(PK \), that was part of the output of an execution of the TLCS protocol for time \(C \), to encrypt measages without specifying any time and only performing cryptographic operations related to the group generated by \(g\) . After time \(C \), using \(SK_C\) and the transcript of the TLCS protocol anyone (and thus a smart contract) can compute the secret key \(sk\) corresponding to \(PK\). Bob can use \(sk\) to decrypt Alice's messages. Observe that, unlike timelock encryption, here the computations of Alice and Bob are completely independent from the LOE system. </p>
<p>We assume that there is a blockchain on which anyone (or possibly only registered people to avoid DoS) can post data as a mean to generate a public key PK and some related data  that can be used by anyone, and so by a smart contract, to obtain the corresponding secret key \(sk\) at time \(C \) .</p>
<p>Additionally, we want that there is a committee of members that anyone can freely join, that is the set of participants in a particular execution of the protocol is not fixed, and we want the protocol to require just one message of interaction from each participant (assuming a perfect broadcast channel like a blockchain).</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="warmup-a-tlcs-protocol-from-general-purpose-nizk-proofs"><a class="header" href="#warmup-a-tlcs-protocol-from-general-purpose-nizk-proofs">Warmup: a TLCS protocol from general-purpose NIZK proofs</a></h2>
<p>Consider the following protocol.
The generic party \(i=1,... \) does the following. It computes \(PK_i=g^{sk_i} \), where \(sk_i \) is randomly chosen in \(Z_q \). 
It chooses random \(t_i \) from \(Z_p \) and computes \(T_i=g_2^{t_i} \), \(Z_i=e(H(C),PK_L)^{t_i} \) and \(y_i=H(Z_i) \oplus sk_i \).
The party \(i \) posts on the blokchain:
\)(T_i, y_i) \). Note that \(Z_i \) is not posted, and the honest party is required to delete \(Z_i, t_i,sk_i \) from his memory, so that until time \(C \) nobody can get \(sk_i \).</p>
<p>At some point, the public key construction phase terminates and no new party can participate.
Then, the public key \(PK \) is set to \(PK=\prod_i PK_i=g^{sk} \), where \(sk=\sum_i sk_i \mod q \).</p>
<p>When the secret \(SK_C=H(C)^{sk_L} \) of LOE is published at time \(C \), anyone can publicly do the following based on the information posted on the blockchain.
For any \(i \) compute \(e(SK_C,T_i)=Z_i \) and then can compute \(sk_i=y_i \oplus H(Z_i) \).</p>
<p>From all \(sk_i \)'s, anyone can then recover \(sk=\sum_i sk_i \mod q \).</p>
<p>The security here guarantees that if only a single party is trusted in having deleted his memory at the of the computation, then the secret key \(sk \) corresponding to \(PK \) is protected until time \(C \) assuming that the majority of LOE members are honest.
That is, the only added assumption beyond LOE is that there is a single honest party. Observe that, since anyone can publicly participate in the protocol (that is the committee allows on-fly join), if someone does not trust the system can decide on participating in the protocol freely.</p>
<p>To be able to decrypt we need to assume that the values \(y_i \)'s posted on the blockchain are computed correctly according to the above procedure, so each \(y_i \) needs to be accompained with a ZK proof of well-formedness, that is a proof that the tuple \((g_2,PK_L,C,T_i,PK_i,y_i) \) is such that there exist values \(t_i\in Z_p \), \(sk_i\in Z_q \) such that \(T_i=g_2^{t_i} \), \(Z_i=e(H(C),PK_L)^{t_i} \), \(y_i=H(Z_i) \oplus sk_i \) and \(PK_i=g^{sk_i} \).
The proof system needs to be non-malleable to prevent attacks in which the last party can induce a public key of which he knows the corresponding secret key; alternatively, a standard non-interactive Schnorr's proof must be attacked to each partial public key \(PK_i \).</p>
<p>This requires a NIZK proof of computation of exponentiation in the target group. Notice that if a tuple \((PK_i,T_i,y_i) \) does not come with a valid proof, it will not be used for the computation of \(PK \). </p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="an-efficient-tlcs-protocol-that-avoids-general-purpose-nizk-proofs"><a class="header" href="#an-efficient-tlcs-protocol-that-avoids-general-purpose-nizk-proofs">An efficient TLCS protocol that avoids general-purpose NIZK proofs</a></h2>
<p>The above NIZK proof could be implemented with general-purpose SNARK for circuits that compute operations in the target group of the LOE's curve. 
In this section we show how to implement a variant of the above protocol that avoids general-purpose NIZK proofs.</p>
<p>(In the following we will be focusing on a single party so we will remove the subscript \(i \) that refers to the parties. So when you read \(PK \), this is actually \(PK_i \) of the previous notation and not the public key that is the result of the shares of all committee members. We choose to do that to minimize the number of subscripts to fit better in hackmd.)</p>
<p>We will construct an interactive protocol. This can be done non-interactive via the FS transform. </p>
<p>There is a security parameter \(k \) that affects the soundness error, precisely the soundness error will be \(2^{-k} \) so there is a trade-off: we have freedom to choose \(k \) as large as possible to reduce the soundness error and as small as possible to make the system more efficient.</p>
<p>The generic party (the prover) has a public key \(PK=g^{sk} \), where \(sk\in Z_q \) is known to the prover but not to the verifier.
For \(j=1,\ldots,k \) the prover chooses two random values \(sk_{j,1},sk_{j,2} \) that sum up to \( sk \) and sets \( PK_{j,1}=g^{sk_{j,1}},PK_{j,2}=g^{sk_{j,2}} \). </p>
<p>For \(j=1,\ldots, k \), the prover chooses random \(t_{j,1},t_{j,2} \) from \(Z_p \) and computes \(T_{j,1}=g_2^{t_{j,1}} \), \(Z_{j,1}=e(H(C),PK_L)^{t_{j,1}} \) and \(y_{j,1}=H(Z_{j,1}) \oplus sk_{j,1} \) and similarly \(T_{j,2},Z_{j,2},y_{j,2} \).
The prover sends to the verifier the value \(PK \) and the list of tuples:
\)(PK_{j,b},T_{j,b_j},y_{j,b})_{j\in[k],b\in{1,2}} \). </p>
<p>(Note: as explained before here we removed the subscript \(i \) so \(PK \) refers to the contribution of a generic party and not to the final public key that is computed as product of the public keys of all members. We do not include the further subscript \(i \) to avoid many subscripts like &quot;\(PK_{i,j,b_j} \)&quot;, etc.)</p>
<p>The verifier chooses a vector of \(k \) random values \(b_1,\ldots,b_k \) in \({1,2} \) and sends it to the prover.
For all \(j\in[k] \) the prover sets \(t_j=t_{j,b_j} \) and sends back to the verifier the tuple \((t_j)_{j\in[k]} \). The verifier accepts iff all the following checks pass:</p>
<ul>
<li>
<ol>
<li>For all \(j=1,\ldots,k \) check that \(PK_{j,1}* PK_{j,2}=PK \).
That is, the verifier checks that all the pairs of public keys form a \(2 \) out of \(2 \) secret sharing of the same public key \(PK \). This also convinces the verifier that the same condition holds with respect to the secret keys, that is that for all \(i=1,\ldots,k \), \(sk_{j,1}+sk_{j,2}=sk \) modulo \(q \), where \(PK=g^{sk} \).</li>
</ol>
</li>
<li>
<ol start="2">
<li>The verifier now checks that the tuple \(PK_{j,b_j},T_{j,b_j},y_{j,b_j} \) is well-formed in the following way. The verifier computes \(Z_j=e(H(C),PK_L)^{t_j} \). If \(t_j \) was equal to \(t_{j,b_j} \) then it holds that \(Z_j=Z_{j,b_j} \).  The verifier computes \(s_j=H(Z_j) \oplus y_{j,b_j}. \) If \(t_j \) was equal to \(t_{j,b_j} \) then it holds that \(s_j=sk_{j,b_j} \). The verifier checks that \(PK_{j,b_j}=g^{s_j} \) and that \(T_{j,b_j}=g_2^{t_j} \). This convinces the verifier that \(s_j=sk_{j,b_j} \) and that \(sk_{j,b_j} \) is the secret key corresponding to \(PK_{j,b_j} \).</li>
</ol>
</li>
</ul>
<p>Let \(s_{j,1} \) and \(s_{j,2} \) be the values induced by \(SK_C \) that should be equal to resp. \(sk_{j,1} \) and \(sk_{j,2} \) if the prover is honest. 
If \(PK \) was not invertible (that is if \(sk \) is not equal to \(s_{j,1}+s_{j,2}\ mod\ q \) then: if the first check with respect to a generic \(j \) passes then the second check with respect to the same \(j \) can pass only with prob. at most \(1/2 \) over the choice of \(b_j \).
So the prob. that a malicious committee member convinces the verifier is \(1/2^k \).</p>
<p>If the proof passes the public key \(PK \) of the party is accepted and is used to compute the public key for time \(C \) by multiplying together all the public keys of all parties whose proofs were accepted.</p>
<p>At time \(C \), to recover the corresponding secret key \(sk \) using the value \(SK_C=H(C)^{SK_L} \) released by LOE, one runs the following procedure.
- for j=1 to k:</p>
<ul>
<li>For all \( b\in{1,2} \) compute \(e(H(C)^{SK_L},T_{j,b})=Z_{j,b} \), \(s_{j,b}=H(Z_{j,b}) \oplus y_{j,b} \).</li>
<li>If \( g^{s_{j,1}}=PK_{j,1} \) and \(g^{s_{j,2}}=PK_{j,2} \) and \(PK_{j,1} * PK_{j,2}=PK \) then return \(sk=s_{j,1}+s_{j,2}\ mod\ q \) else continue; </li>
</ul>
<p>The previous proof can be made non-interactive by having the prover to choose the vector \(b_1,...,b_k \) as hash of the string \([PK,(PK_{j,b},T_{j,b_j},y_{j,b})_{j\in[k]}] \).
The verifier does the same to recompute the vector \(b_1,...,b_k \) in a deterministic way.
Under mild conditions  the non-interactive variant can be made weak simulation sound extractable (see <a href="https://eprint.iacr.org/2012/704">here</a>) since the previous TLCS protocol is a sigma protocol.
* TODO: check that the conditions are satisfied.</p>
<h3 id="variants-based-on-general-secret-sharing"><a class="header" href="#variants-based-on-general-secret-sharing">Variants based on general secret sharing</a></h3>
<p>The above system can be modified having in each repetition e.g. a prob. of error of \(1/3 \) instead of \(1/2 \) and with overall shorter proofs.
The idea is the following. 
For each \(j\in[k] \) we can choose e.g. \(3 \) secret keys \(sk_{j,1},...,sk_{j,3} \) so that they form e.g. a \(2 \) out of \(3 \) secret sharing of \(sk \). That is, for all \(i\in[3] \), \(sk_{j,i}=p_j(i) \), where \(p_j \) is a random degree one polynomial whose constant term equals \(sk \). Thus, by means of the Lagrange coefficients, any subset of size \(2 \) of such keys can be used to reconstruct \(sk \).
Then we let as before \(PK_{j,1},...,PK_{j,3} \) be the corresponding public keys.
The verifier in check 1 is changed as follows. The verifier will verify that any subset \(S \) of \({1,...,3} \) of cardinality \(2 \) of such public keys is such that \(\prod_{l\in S} PK_{j,l}^{\lambda_{S,l}}=PK \), where the values \(\lambda_{S,l},l\in S \) are the Lagrange coefficients for set \(S \). Since there are \(3 \) subsets of \( {1,...,3} \) of cardinality \(2 \), check \(1 \) requires \( 3*2=6 \) exponentiations in the cyclic group.
In check \(2 \) the verifier will do the checks as above except for the following change.
Before, the check was with respect to a single random bit. Now the check is with respect to a random index \(k \) in \({1,...,3} \).
Now we notice that if the check \(1 \) passes the party could cheat only if there exists at most one index \(k' \) such that the public key  \(PK_{j,k'} \) is invertible and the verifier happens to choose \(k=k' \) and this occurs with prob. \(1/3 \).
So, with still one exponentiation in the target group per iteration we get error \(1/3 \) and we decreased the communication (the size of the proof).</p>
<p>Experiments show that, though the time performance may not be much better, this approach is preferable when attempting to reduce the communication cost. The time verification cost depends on the ratio of efficiency between exponentiations in target group and exponentiations in the cyclic groups.
If for some cyclic group this ratio were high (that is exponentiations in the target group were much more expensive than exponentiations in the cyclic group), the approach on general secret sharing would also be more efficient in terms of time costs for the verifier. For example, in some applications the period between publication of the tlock public key and revealing of the corresponding secret key could be short; in such case it could make sense to use cyclic groups with short security parameters so that the secret sharing variant could improve more on verification time. In most cases this variant improves slightly on proof size.</p>
<p>For the concrete case of e.g. a 2 out of 3 SS one can choose the interpolation points so as to make the Lagrange coefficients to be small integers. </p>
<h4 id="random-check-trick"><a class="header" href="#random-check-trick">Random check trick</a></h4>
<p>Another trick to make the SS variant more efficient is the following. Let us assume a 2 out of 4 SS as above. The verifier can be modified so as to choose random scalars \(r_j,j\in[k] \) and to set for each \(l\in [4] \):</p>
<p>$$RPK_{l}=\prod_{j\in[k]}PK_{j,l}^{r_j} $$</p>
<p>Then, the verifier can check for each subset \(S \) of \([4] \) of cardinality \(2 \)  that:</p>
<p>\( \prod_{l\in S} RPK_{l}^{\lambda_{S,l}}=PK^{\sum_{j\in[k]} r_j} \) 
In this way, the verifier would do a number of exponentiations in the cyclic group of the order \(4k+13 \) rather than \(12k \), and this should make the verifier of the 2 out of 4 SS variant more efficient.</p>
<ul>
<li>TODO: check the soundness of the approach and implement it.</li>
</ul>
<h3 id="generalization-to-any-homomorphic-owf-and-thus-to-rsa"><a class="header" href="#generalization-to-any-homomorphic-owf-and-thus-to-rsa">Generalization to any homomorphic OWF and thus to RSA</a></h3>
<p>The previous protocol only uses the following facts:
- The exponentiation in a cyclic group is difficult to invert (for security).
- The exponentiation in a cyclic group is easy to check, that is given \(sk \) and \(PK \) it is easy to check if \(PK=g^{sk} \).
- The exponentiation in a cyclic group is homomorphic, that is the product of two public keys \(PK_1,PK_2 \) whose secret keys are resp. \(sk_1,sk_2 \) is a public key \(PK \) such that the corresponding secret key \(sk \) equals \(sk_1+sk_2 \) modulo the order of the group. </p>
<p>This can be generalized to any homomorphic one-way function (OWF). Exponentiation in cyclic groups are examples of homomorphic OWFs but another notable example is RSA.
Given a modulus \(N \) product of two safe primes and an exponent \(d\in Z_{\phi(\phi(N))} \), the RSA function \(f_{RSA} \) is the function that maps \(x \) to \(x^d\ mod\ N \). This function can be seen to be also homomorphic.
Note that we do not claim that we can use this directly for OAEP or related RSA-based encryption schemes.</p>
<p>Additioanlly, we have a trapdoor: if a party has the factorization of the modulus, this party is able to invert the evaluation of the function \(PK=f_{RSA}(sk) \) before the prescribed time to get the corresponding secret key \(sk \). 
Observe that the variant with general secret sharing does not generalize to RSA and all homomorphic OWF. </p>
<h3 id="how-to-guarantee-that-anyone-can-freely-join-without-spamming-the-blockchain"><a class="header" href="#how-to-guarantee-that-anyone-can-freely-join-without-spamming-the-blockchain">How to guarantee that anyone can freely join without spamming the blockchain?</a></h3>
<p>Depending on the resources of the nodes it might be possible only to verify proofs and accept the contribution of a small fraction of the total committee members, especially if huge number of parties want to contribute. For concreteness, it might be that the nodes have resources to work only on \(N \) committee members.
In that case, the blockchain can do the following. There is a time \(d \) before which parties can submit their contribution. At time \(d \) one sees the random beacon published by LOE and this value is used to select (e.g., via a cryptographic hash function) a random subset of committee members of size \(N \) among all committee members who took part in the protocol. The unpredictability of the random beacon of LOE makes hard to cheat and allows fair choice of the committee members in the limit of the resources of the nodes.</p>
<h3 id="from-tlcs-to-timed-signatures-and-timed-proofs"><a class="header" href="#from-tlcs-to-timed-signatures-and-timed-proofs">From TLCS to timed signatures and timed proofs</a></h3>
<p>Borrowing ideas from the celebrated Feige-Lapidot-Shamir technique, the Schnorr signature scheme can be modified so that the underlying sigma protocol on which it is based proves knowledge of a witness to the following \(NP \) statement: &quot;I know a secret key corresponding to \(PK_{A} \) OR I know a secret key corresponding to \(PK \)&quot;, where \(PK_A \) is a known public key of a user Alice and \(PK \) is a TLCS public key \(PK \) for some time \(C \).</p>
<p>In this way a resulting signature is such that: a valid signature by Alice looks convincing to Bob before time \(C \) but if Bob transfers this signature to Peggy after time \(C \), such signature will not look convincing to Peggy since it might have been generated by anyone using the simulator algorithm of the sigma protocol using the secret key corresponding to \(PK \) (that may be assumed to be known by anyone after time \(C \)).</p>
<p>The same concept can be extended to general-purpose NIZK proofs that can be made to guarantee the following property: they are publicly verifiable until a given time \(C \) but after \(C \) they will be no longer transferable (that is, they will no longer look convincing to any receiver).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="correctness"><a class="header" href="#correctness">Correctness</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="security-1"><a class="header" href="#security-1">Security</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h2 id="curve-implementations"><a class="header" href="#curve-implementations">Curve implementations</a></h2>
<p>Now our TLCs protocol support some popular elliptic curves, that are implemented in arkwrorks library:</p>
<p>BLS12-381 and embedded curves
ark-bls12-381: Implements the BLS12-381 pairing-friendly curve
ark-ed-on-bls12-381: Implements a Twisted Edwards curve atop the scalar field of BLS12-381
ark-ed-on-bls12-381-bandersnatch: Implements Bandersnatch, another Twisted Edwards curve atop the scalar field of BLS12-381
BLS12-377 and related curves
ark-bls12-377: Implements the BLS12-377 pairing-friendly curve</p>
<p>ark-ed-on-bls12-377: Implements a Twisted Edwards curve atop the scalar field of BLS12-377</p>
<p>ark-bw6-761: Implements the BW6-761 pairing-friendly curve, which is a curve whose scalar field equals the base field of BLS12-377</p>
<p>ark-ed-on-bw6-761: Implements a Twisted Edwards curve atop the scalar field of BW6-761</p>
<p>ark-cp6-782: Implements the CP6-782 pairing-friendly curve, which is a curve whose scalar field equals the base field of BLS12-377</p>
<p>ark-ed-on-cp6-782: Implements a Twisted Edwards curve atop the scalar field of CP6-782. This is the same curve as in ark-ed-on-bw6-761</p>
<p>BN254 and related curves
ark-bn254: Implements the BN254 pairing-friendly curve
ark-ed-on-bn254: Implements a Twisted Edwards curve atop the scalar field of BN254
ark-grumpkin: Implements the Grumpkin curve. A curve that forms a cycle with bn254.
MNT-298 cycle of curves and related curves
ark-mnt4-298: Implements the MNT4-298 pairing-friendly curve. This curve forms a pairing-friendly cycle with MNT6-298
ark-mnt6-298: Implements the MNT6-298 pairing-friendly curve. This curve forms a pairing-friendly cycle with MNT4-298
ark-ed-on-mnt4-298: Implements a Twisted Edwards curve atop the scalar field of MNT4-298
MNT-753 cycle of curves and related curves
ark-mnt4-753: Implements the MNT4-753 pairing-friendly curve. This curve forms a pairing-friendly cycle with MNT6-753
ark-mnt6-753: Implements the MNT6-753 pairing-friendly curve. This curve forms a pairing-friendly cycle with MNT4-753
ark-ed-on-mnt4-753: Implements a Twisted Edwards curve atop the scalar field of MNT4-753
Pasta cycle of curves
ark-pallas: Implements Pallas, a prime-order curve that forms an amicable pair with Vesta
ark-vesta: Implements Vesta, a prime-order curve that forms an amicable pair with Pallas</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="implementation"><a class="header" href="#implementation">Implementation</a></h1>
<p>An implementation in C/C++ of the efficient TLCS protocol described above is available <a href="https://github.com/aragonzkresearch/tlcs-c">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tlcs---c"><a class="header" href="#tlcs---c">TLCS - C++</a></h1>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>The repository provides implementation of the efficient TLCS protocol described in this <a href="https://hackmd.io/WYp7A-jPQvK8xSB1pyH7hQ">note</a> that builds on the LOE (a.k.a. <a href="https://github.com/drand/drand">drand</a> ) service. The implementation is based on the <a href="https://github.com/herumi/mcl/">mcl</a> library and openssl.</p>
<p>The TLCS library allows to create public keys for virtually any elliptic curve supported by openssl and in addition the <code>G1</code> group of the <code>BLS12_381</code> curve and the babyjubjub curve.
To use the <code>G1</code> group set <code>-D_CYC_GRP_BLS_G1=1</code>  in the <code>Makefile</code> before installation or use the corresponding library. Observe that in this case you should be sure that cryptosystem is secure in that group. To use RSA set <code>-D_CYC_GRP_RSA=1</code> or use the corresponding library. </p>
<h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<pre><code class="language-bash">git clone https://github.com/herumi/mcl.git
cd mcl
make all
cd ..
chmod u+x install.sh
./install.sh
</code></pre>
<h2 id="apis"><a class="header" href="#apis">APIs</a></h2>
<p>The APIs can be divided in routines for:</p>
<ul>
<li>the prover contained in the file <code>src/prover.c</code></li>
<li>for the verifier in <code>src/verifier.c</code></li>
<li>for inversion of the public key in <code>src/invert.c</code></li>
<li>aggregation of the participants' public keys in <code>src/aggregate.c</code> </li>
</ul>
<p>The prover, verifier and inversion have corresponding versions for the secret sharing variant.</p>
<h2 id="news"><a class="header" href="#news">News</a></h2>
<ul>
<li>20-May-2023 Added experimental support for the secret sharing variant.</li>
<li>16-May-2023 Added experimental support for babyjubjub ec.</li>
<li>14-May-2023 Added support for RSA.</li>
<li>07-May-2023 Launch!</li>
</ul>
<h2 id="demo"><a class="header" href="#demo">Demo</a></h2>
<p>The source code contains a file * <code>examples/tlcs.c</code> implementing a demo simulation of a TLCS activity using the routines in the library. 
The demo is supposed to simulate locally a TLCS protocol consisting of proving, verification, aggregation and inversion phases. </p>
<h3 id="example-of-usage-of-the-demo"><a class="header" href="#example-of-usage-of-the-demo">Example of usage of the demo</a></h3>
<pre><code class="language-bash">./bin/demo_prover proof
</code></pre>
<p>The previous command will simulate a party that creates his public key and proof and writes it to the file named <code>proof</code>.
The demo will ask you for which type of curve you want to generate your public key and for a round number <code>T</code> of LOE with respect to which you want that the protocol is executed. 
The file is intented to simulate a blockchain activity so if you will re-execute the same command with same file, you will simulate another party who wrote to the blockchain.
Let us suppose we executed the command twice and in each execution we used the same file <code>proof</code>, the same curve number (e.g., <code>714</code>) and we selected the same input <code>T</code>.</p>
<p>Now, the file <code>proof</code> contains the public keys and the proofs of two parties. </p>
<pre><code class="language-bash">./bin/demo_verifier proof verificationresult
</code></pre>
<p>The previous command simulates a verifier that reads the fil <code>proof</code> and writes an array of 0/1 results in the file <code>verificationresult</code>. The i-th element of the array is <code>1</code> if the proof of the i-th party is verifid successfully and <code>0</code> otherwise.
So, in our example after the execution of the last command, the fil <code>verificationresult</code> will contain the string <code>1 1</code> to indicate that both proofs of the two parties were successfully verified.</p>
<pre><code class="language-bash">./bin/demo_aggregator proof aggregated_pk 1 1
</code></pre>
<p>The previous commands simulates the aggregation phase of the protocol. The aggregator reads the file <code>proof</code> that in our example contains the output of two parties and uses the list <code>1 1</code> to know which party computed valid proof (in our example both parties computed valid proofs so the list is <code>1 1</code>) and outputs the aggregated public key in the file <code>aggregated_pk</code>.</p>
<p>At time corresponding to round number <code>T</code>, LOE publishes a signature for the round <code>T</code> (the link where to get this signature was printed out after executing <code>demo_prover</code>).</p>
<pre><code class="language-bash">./bin/demo_invert proof aggregated_pk 1 1
</code></pre>
<p>The previous command simulates the inversion phase in which after time corresponding to round <code>T</code> we aim at inverting the aggregated public key contained in the file <code>aggregated_pk</code>. To this purpose we pass as input to the latter program the file <code>proof</code> that contains the public keys of all parties who participated in the protocol and their respective proofs, the aggregate public key file <code>aggregated_pk</code> and, in our example, the list of 0/1 values <code>1 1</code> to indicate that the file <code>proof</code> contains two proofs that are both accepted.
The program will ask for you for the signature of LOE of round <code>T</code> and should print out the secret key corresponding to the aggregated public key in the file <code>aggregated_pk</code>.</p>
<h2 id="how-to-use-our-tlcs-system"><a class="header" href="#how-to-use-our-tlcs-system">How to use our TLCS system</a></h2>
<p>See our <a href="https://github.com/aragonzkresearch/tlcs-c/blob/main/examples/howtoencrypt.md">How to Use</a> page for examples on how to use our system to encrypt.</p>
<h2 id="contacts"><a class="header" href="#contacts">Contacts</a></h2>
<p>Vincenzo Iovino (vincenzo@aragon.org)</p>
<p>Aragon ZK Research Team: https://research.aragon.org/</p>
<h2 id="references"><a class="header" href="#references">References</a></h2>
<p>Vincenzo Iovino. <a href="https://hackmd.io/WYp7A-jPQvK8xSB1pyH7hQ">How to Build a Time Lock Crypto Service based on League of Entropy</a>, May 2023.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust"><a class="header" href="#rust">rust</a></h1>
<p><a href="https://github.com/aragonzkresearch/tlcs-rust">Here</a> you can find the TLCS in Rust. The repository provides implementation of the efficient TLCS protocol (in <code>rust</code>), described in this <a href="https://github.com/aragonzkresearch/blog/blob/main/pdf/azkr-timelock-zone.pdf">note</a> that builds on the LOE (a.k.a. <a href="https://github.com/drand/drand">drand</a> ) service. In this implementation we used <a href="https://github.com/arkworks-rs"><code>arkworks</code></a> which is a <code>rust</code> ecosystem for zkSNARK programming.</p>
<p><strong>Important Note:</strong></p>
<ol>
<li>This section is still a work in progress and has not reached its completion.</li>
<li>This portion of the code is experimental and not yet ready for usage in the main project.</li>
<li>Some of the components in this repo have not yet passed the required tests.</li>
<li>More information on the protocol and methods can be found here: <a href="https://github.com/aragonzkresearch/blog/blob/main/pdf/azkr-timelock-zone.pdf">azkr-timelock-zone</a> and <a href="https://hackmd.io/WYp7A-jPQvK8xSB1pyH7hQ">How to Build a Time Lock Crypto Service based on League of Entropy.</a></li>
</ol>
<h2 id="goal"><a class="header" href="#goal">Goal:</a></h2>
<p>The TLCS library allows to create public keys for any<a href="https://github.com/arkworks-rs/curves"> elliptic curve supported by <code>arkwork</code></a> and in addition the <code>G1</code> group of the <code>BLS12_381</code> curve and the babyjubjub curve.</p>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="timelock-encryption"><a class="header" href="#timelock-encryption">Timelock Encryption</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="commitment"><a class="header" href="#commitment">Commitment</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="zk-with-expiration-time"><a class="header" href="#zk-with-expiration-time">ZK with expiration time</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="e-voting"><a class="header" href="#e-voting">e-voting</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="time-document-release"><a class="header" href="#time-document-release">time document release</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id=""><a class="header" href="#"></a></h1>
<h1 id="timelockfs"><a class="header" href="#timelockfs">timelock.fs</a></h1>
<p><code>timelock.fs</code> is an extension for the <a href="https://www.timelock.zone">timelock.zone</a> service that enables to encrypt to the future and decrypts any file using Windows Explorer.
See also <a href="https://github.com/aragonzkresearch/tlcs-c/">tlcs-c</a>, <a href="https://github.com/aragonzkresearch/tlcs-rust/">tlcs-rust</a>, <a href="https://github.com/vincenzoiovino/Timelock.zone.AndroidExample">Timelock.zone.AndroidExample</a>, <a href="https://github.com/vincenzoiovino/timelock.public.disclosure">timelock.public.disclosure</a> and <a href="https://github.com/aragonzkresearch/tlcs-c/blob/main/examples/howtoencrypt.md">TLCS Usage</a>.</p>
<p>Disclaimer: currently we used a very old version of <code>bouncycastle</code> for simplicity and we did not care about enforcing more stringent level of security for <code>ECIES</code>. This repo is only for testing <code>timelock.zone</code> functionalities. You can easy adapt all code to any <code>bouncycastle</code> version and different <code>ECIES</code> variant. </p>
<h2 id="installation-1"><a class="header" href="#installation-1">Installation</a></h2>
<h3 id="install-from-source"><a class="header" href="#install-from-source">Install from source</a></h3>
<p>Add as dependencies <code>bcprov-jdk15on-168.jar</code>, <code>json-simple-1.1.jar</code> and <a href="https://github.com/vincenzoiovino/TimelockJavaAPI/tree/main"><code>timelock.zone.jar</code></a>.
Use <code>Java</code> tools or any IDE to build from the source code a runnable Jar file named <code>timelock.fs.jar</code> and stores it in the <code>bin</code> folder or in any other folder: the only requirement is that the files <a href="https://github.com/vincenzoiovino/timelock.fs/blob/main/bin/install.bat"><code>install.bat</code></a> and <a href="https://github.com/vincenzoiovino/timelock.fs/blob/main/bin/uninstall.bat"><code>uninstall.bat</code></a> must reside in the same folder as the runnable Jar you created.
Edit the file <code>install.bat</code> with any editor (e.g. Notepad) and change the line:</p>
<pre><code class="language-bash">setx YOUR_JAVA &quot;C:\Program Files\Java\jdk-15.0.2&quot;
</code></pre>
<p>to:</p>
<pre><code class="language-bash">setx YOUR_JAVA &quot;Path&quot;
</code></pre>
<p>where <code>Path</code> is a path to your Java Runtime Environment (<code>JRE</code>) installation you used for the compilation.
You can download JREs from <a href="https://www.oracle.com/java/technologies/downloads/">here</a>. Usually <code>Path</code> has the form <code>C:\Program Files\Java\jdk-XX.Y.Z</code>. If your <code>JRE</code> is installed correctly you should have a file <code>javaw.exe</code> under the folder <code>Path\bin</code>.
Once you edited the file <code>install.bat</code> as described before, you can run <code>install.bat</code>, grant admin permissions (needed to install the Windows extensions) and you are done.</p>
<h3 id="install-without-compilation"><a class="header" href="#install-without-compilation">Install without compilation</a></h3>
<p>Download the file <a href="https://github.com/vincenzoiovino/timelock.fs/blob/main/timelock.fs.zip"><code>timelock.fs.zip</code></a> and unzip it.  The so created folder <code>timelock.fs</code> contains (among others) a file named <code>install.bat</code>.
Download <a href="https://jdk.java.net/archive/">JDK 17</a> or higher if you do not have already <code>JDK</code>/<code>JRE</code> installed.
Run <code>install.bat</code>, grant admin permissions (needed to install the Windows extensions) and you are done.</p>
<h4 id="installation-issues"><a class="header" href="#installation-issues">Installation issues</a></h4>
<p>The Jar <code>timelock.fs.jar</code> in the file <code>timelock.fs.zip</code> has been compiled with Java Runtime Environment (<code>JRE</code>) 17. If the installation does not work it is because you could have an older <code>JRE</code>. In such case, download <code>JRE</code> 17 (see above) and set <code>JAVA_HOME</code> environment variable to point to the new <code>JRE</code> folder. Another reason of installation failure could be that <code>JAVA_HOME</code> is not set at all, in such case set it to point to your <code>JRE</code> folder.</p>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<h3 id="encrypt-to-the-future"><a class="header" href="#encrypt-to-the-future">Encrypt to the future</a></h3>
<p>You can right click on any file, e.g. <code>MyFile.pdf</code>, in Windows Explorer, select <code>Show more options</code> (this may depend on your Windows version) and then click on <code>timelock.fs.encrypt</code>.
You will be prompted to choose a date in the future in the format DD/MM/YYYY and an hour. Then you will just have to click on the <code>Encrypt</code> button. It will be created a file <code>MyFile.pdf.tlcs</code> that contains the encrypted version of the file <code>MyFile.pdf</code>. You can now delete the original file <code>MyFile.pdf</code> if you want to hide it until the chosen day.</p>
<h3 id="decrypt"><a class="header" href="#decrypt">Decrypt</a></h3>
<p>The encrypted file is protected until the day before the chosen date.
When the chosen day and hour is reached you can right click on the file <code>MyFile.pdf.tlcs</code>, select <code>Show more options</code> (this may depend on your Windows version) and then click on <code>timelock.fs.decrypt</code>. Your file will be decrypted and you will recover the file <code>MyFile.pdf</code>.</p>
<h2 id="uninstall"><a class="header" href="#uninstall">Uninstall</a></h2>
<p>To uninstall the <code>timelock.fs</code> extensions, run <a href="https://github.com/vincenzoiovino/timelock.fs/blob/main/bin/uninstall.bat"><code>uninstall.bat</code></a> (you must grant admin permissions) from the same folder where you launched <code>install.bat</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="escrow-services"><a class="header" href="#escrow-services">escrow services</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="legal-and-compliance-purposes"><a class="header" href="#legal-and-compliance-purposes">legal and compliance purposes</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="legal-and-compliance-purposes-1"><a class="header" href="#legal-and-compliance-purposes-1">Legal and compliance purposes</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
